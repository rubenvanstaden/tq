package tq

import (
	"context"
	"encoding/json"
	"log"
)

type Broker interface {

	// Add new messages to stream.
	Enqueue(ctx context.Context, message *TaskMessage) error

	// Pull new messages from stream.
	Messages(ctx context.Context, name string) ([]*TaskMessage, error)
}

// The data structure that goes on the broker.
// Internal representation of a task with metadata.
// Serialized data of this type gets enqueued.
type TaskMessage struct {

	// The message ID that gets generated by the broker.
	// This field is only added when an event gets consumed.
	Id string `json:"id"`

	// Holds the serialized signature.
	Payload []byte `json:"payload"`

	// Is the message a retry
	Retry string `json:"retry"`
}

func DecodeMessage(messageId string, val map[string]interface{}) *TaskMessage {

	jsonbody, err := json.Marshal(val)
	if err != nil {
		panic(err)
	}

	msg := TaskMessage{}
	if err := json.Unmarshal(jsonbody, &msg); err != nil {
		panic(err)
	}

	msg.Id = messageId

	return &msg
}

func (s TaskMessage) EncodeToMap() map[string]interface{} {

	var values map[string]interface{}

	data, err := json.Marshal(s)
	if err != nil {
		log.Fatalf("Unable to marshall task: %s", err)
	}

	err = json.Unmarshal(data, &values)
	if err != nil {
		panic(err)
	}

	return values
}
